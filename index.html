<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>dar-prototype — GitHub Pages</title>
<style>
  /* Global reset + disable text selection/touch callouts */
  html,body{margin:0;padding:0;background:#0e0f12;color:#e8e8ea;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;height:100%;overscroll-behavior:none}
  *{user-select:none;-webkit-user-select:none;-ms-user-select:none;-webkit-touch-callout:none}
  canvas{position:fixed;inset:0;z-index:0;touch-action:none}
  #ui{position:fixed;inset:auto 0 0 0;display:flex;gap:.5rem;align-items:center;padding:.6rem .8rem;background:linear-gradient(180deg,rgba(14,15,18,0),rgba(14,15,18,.7) 30%,rgba(14,15,18,.9));backdrop-filter:blur(6px);z-index:10;pointer-events:auto;flex-wrap:wrap}
  .btn{border:1px solid #3a3d45;padding:.45rem .7rem;border-radius:999px;background:#181a20;color:#e8e8ea;font-weight:600;letter-spacing:.2px}
  .btn.active{background:#0066ff;border-color:#4c8dff}
  .row{display:flex;gap:.5rem;align-items:center;flex-wrap:wrap}
  .grow{flex:1}
  .tag{background:#181a20;border:1px solid #3a3d45;padding:.3rem .55rem;border-radius:999px;font-size:.85rem}
  .tag.good{border-color:#2ecc71;color:#baf7d1}
  .tag.bad{border-color:#ff5c5c;color:#ffd3d3}
  .hidden{display:none!important}

  #scoreHud{position:fixed;top:.6rem;left:.6rem;z-index:15;display:flex;gap:.75rem;align-items:center;flex-wrap:wrap;pointer-events:none}
  #hud{position:fixed;top:.6rem;left:.6rem;right:.6rem;display:flex;gap:.75rem;align-items:center;z-index:11;pointer-events:none;flex-wrap:wrap}

  #menuBtn{position:fixed;top:.6rem;right:.6rem;z-index:16;width:44px;height:44px;border-radius:12px;border:1px solid #3a3d45;background:#181a20;display:grid;place-items:center;box-shadow:0 2px 10px rgba(0,0,0,.25)}
  #menuBtn .bar{display:block;width:20px;height:2px;background:#e8e8ea;margin:3px 0}
  #menuBtn.active{background:#0066ff;border-color:#4c8dff}

  #spinControls,#l1Diff{display:none;align-items:center;gap:.5rem}
  input[type=range]{accent-color:#4c8dff}

  #goalPanel{position:fixed;top:0;left:0;right:0;z-index:20;pointer-events:auto;display:flex;justify-content:center;padding:.75rem}
  #goalCard{pointer-events:auto;max-width:680px;width:calc(100% - 1.2rem);background:rgba(24,26,32,.92);border:1px solid #3a3d45;border-radius:14px;padding:.8rem 1rem;box-shadow:0 8px 24px rgba(0,0,0,.35)}
  #goalCard h3{margin:.1rem 0 .35rem 0;font-size:1rem}
  #goalCard p{margin:0;line-height:1.35;opacity:.92}
  #goalCard .actions{display:flex;gap:.5rem;margin-top:.6rem}
  #goalCard .actions .btn{padding:.35rem .6rem}

  /* L1 vertical spin slider — flush left */
  #l1SpinContainer{position:fixed;left:0;top:32%;transform:translateY(-50%);z-index:12;display:none;flex-direction:column;align-items:flex-start;gap:6px;pointer-events:auto}
  #l1SpinLabel{font:600 13px system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;color:#e8e8ea;background:#181a20;border:1px solid #3a3d45;border-radius:999px;padding:2px 8px;white-space:nowrap;margin-left:4px}
  #l1SpinSlider{position:absolute;left:0;top:22px;-webkit-appearance:slider-vertical;writing-mode:bt-lr;width:30px;height:220px;margin:0;background:transparent}

  /* L2 vertical target-size slider — flush left */
  #l2SizeContainer{position:fixed;left:0;top:32%;transform:translateY(-50%);z-index:12;display:none;flex-direction:column;align-items:flex-start;gap:6px;pointer-events:auto}
  #l2SizeLabel{font:600 13px system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;color:#e8e8ea;background:#181a20;border:1px solid #3a3d45;border-radius:999px;padding:2px 8px;white-space:nowrap;margin-left:4px}
  #l2SizeSlider{position:absolute;left:0;top:22px;-webkit-appearance:slider-vertical;writing-mode:bt-lr;width:30px;height:220px;margin:0;background:transparent}

  #level2hud,#level3hud{align-items:center;gap:.5rem}

  /* Joy reposition hint bubble */
  #joyHint{
    position:fixed; z-index:13; pointer-events:none;
    background:rgba(24,26,32,.92); border:1px solid #3a3d45; color:#cfd3dc;
    padding:.35rem .55rem; border-radius:10px; font-size:.85rem; white-space:nowrap;
    transform:translate(-50%,-50%); opacity:0; transition:opacity .25s ease;
  }
  #joyHint.show{opacity:1;}

  /* Zoom slider group */
  .zoomGroup{display:flex;gap:.5rem;align-items:center}
  #zoomRange{width:160px}
</style>
</head>
<body>
  <button id="menuBtn" class="hamburger" type="button" aria-label="Toggle UI" title="Toggle UI">
    <span class="bar"></span><span class="bar"></span><span class="bar"></span>
  </button>

  <div id="goalPanel" class="hidden">
    <div id="goalCard">
      <h3 id="goalTitle">Level Goal</h3>
      <p id="goalText">…</p>
      <div class="actions"><button id="goalClose" class="btn">Got it</button></div>
    </div>
  </div>

  <!-- Joy reposition hint -->
  <div id="joyHint">Hold outside the stick for 0.25s to reposition</div>

  <!-- L1 spin slider (vertical, flush left) -->
  <div id="l1SpinContainer">
    <div id="l1SpinLabel">Spin: 0 (stationary)</div>
    <input id="l1SpinSlider" type="range" min="0" max="1" step="0.01" value="0" />
  </div>

  <!-- L2 target-size slider (vertical, flush left) -->
  <div id="l2SizeContainer">
    <div id="l2SizeLabel">Target Ø: 56px</div>
    <input id="l2SizeSlider" type="range" min="36" max="120" step="1" value="56" />
  </div>

  <!-- Score/result -->
  <div id="scoreHud">
    <div id="score" class="tag">Score 0 / 0</div>
    <div id="result" class="tag" style="display:none;"></div>
  </div>

  <!-- Level HUDs -->
  <div id="hud">
    <div id="level2hud" style="display:none;">
      <span class="tag" id="tempoTag">Tempo 1.15 s/rot</span>
      <span class="tag" id="aimTag">Aim —</span>
    </div>
    <div id="level3hud" style="display:none;">
      <span class="tag" id="speedTag">Speed 0 px/s</span>
      <span class="tag" id="distTag">Dist 0 m</span>
      <span class="tag" id="livesTag">Lives 3</span>
    </div>
  </div>

  <!-- Controls -->
  <div id="ui">
    <div class="row">
      <button id="level1" class="btn active" type="button">Level 1</button>
      <button id="level2" class="btn" type="button">Level 2</button>
      <button id="level3" class="btn" type="button">Level 3</button>
      <button id="rollL" class="btn" type="button">Air Roll Right</button>
      <button id="rollR" class="btn active" type="button">Air Roll Left</button>
      <button id="swapUD" class="btn" type="button">Swap U/D</button>
      <button id="restart" class="btn" type="button">Restart</button>
      <button id="hintBtn" class="btn" type="button">Hint</button>
      <div class="grow"></div>

      <!-- Zoom controls -->
      <div class="zoomGroup">
        <button id="zoomOut" class="btn" type="button" title="Zoom out">Zoom −</button>
        <input id="zoomRange" type="range" min="0.5" max="1.5" step="0.01" value="1.00" />
        <button id="zoomIn" class="btn" type="button" title="Zoom in">Zoom +</button>
        <span class="tag" id="zoomTag">Zoom 1.00×</span>
      </div>

      <div id="l1Diff">
        <label for="diffRange" class="tag">L1 Difficulty</label>
        <input id="diffRange" type="range" min="1" max="5" step="1" value="3" />
        <span class="tag" id="diffTag">Tol 10° • Radius 22 • Window 100ms</span>
      </div>
      <div id="spinControls">
        <label for="spinRange"><span id="spinLabelPrefix">L2 Spin</span> (s/rot, min=1.15):</label>
        <input id="spinRange" type="range" min="1.15" max="3.00" step="0.05" value="1.15" />
        <span class="tag" id="spinValue">1.15 s/rot</span>
      </div>
    </div>
  </div>

  <script>
  /* ====== lightweight p5-ish helpers (no external libs) ====== */
  let canvas, ctx, width, height;
  const _state={strokeStyle:'#fff',fillStyle:'#fff',lineWidth:1,doStroke:true,doFill:true};
  function _apply(){ctx.strokeStyle=_state.strokeStyle;ctx.fillStyle=_state.fillStyle;ctx.lineWidth=_state.lineWidth;}
  function createCanvas(w,h){canvas=document.createElement('canvas');ctx=canvas.getContext('2d');canvas.width=width=w;canvas.height=height=h;canvas.style.touchAction='none';document.body.appendChild(canvas);return{elt:canvas};}
  function resizeCanvas(w,h){canvas.width=width=w;canvas.height=height=h;}
  function background(c){ctx.save();ctx.setTransform(1,0,0,1,0,0);ctx.fillStyle=c;ctx.fillRect(0,0,width,height);ctx.restore();}
  function stroke(c){_state.doStroke=true;_state.strokeStyle=c;} function noStroke(){_state.doStroke=false;}
  function fill(c){_state.doFill=true;_state.fillStyle=c;} function noFill(){_state.doFill=false;}
  function strokeWeight(w){_state.lineWidth=w;}
  function line(x1,y1,x2,y2){_apply();ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);if(_state.doStroke)ctx.stroke();}
  function circle(x,y,d){_apply();ctx.beginPath();ctx.arc(x,y,d/2,0,Math.PI*2);if(_state.doFill)ctx.fill();if(_state.doStroke)ctx.stroke();}
  function arc(x,y,w,h,a1,a2){_apply();ctx.beginPath();ctx.ellipse(x,y,w/2,h/2,0,a1,a2);if(_state.doStroke)ctx.stroke();}
  function push(){ctx.save();} function pop(){ctx.restore();} function translate(x,y){ctx.translate(x,y);} function rotate(a){ctx.rotate(a);}
  function radians(d){return d*Math.PI/180;} function degrees(r){return r*180/Math.PI;}
  function millis(){return performance.now();} function random(a,b){if(a===undefined)return Math.random();if(b===undefined)return Math.random()*a;return a+Math.random()*(b-a);}
  function dist(x1,y1,x2,y2){const dx=x2-x1,dy=y2-y1;return Math.hypot(dx,dy);}
  class Vector{constructor(x=0,y=0){this.x=x;this.y=y;}copy(){return new Vector(this.x,this.y);}mag(){return Math.hypot(this.x,this.y);}setMag(m){const c=this.mag();if(c>0){this.x*=m/c;this.y*=m/c;}return this;}mult(s){this.x*=s;this.y*=s;return this;}static add(a,b){return new Vector(a.x+b.x,a.y+b.y);}}
  function createVector(x,y){return new Vector(x,y);}

  /* =================== Game constants =================== */
  const SQUARE_HALF=24,CLEARANCE=4,ARROW_LEN=110;
  const JOY_BASE_R=88,JOY_KNOB_R=28;
  const STICK_TAU_MS=38,ARROW_TAU_MS=55,STICK_MIN_MAG=8;
  const COL_UP='#ff5c5c',COL_RIGHT='#4c8dff',COL_DOWN='#53d769',COL_LEFT='#ffd166';
  const GOAL_MS = 3000; // auto-hide for auto-shown hints
  const JOY_HINT_MS = 4500;

  // Level tuning
  let L1_TOL_DEG=10,L1_TARGET_RADIUS=22,HOLD_TO_ARC_MS=100;
  let L1_SPIN_PERIOD_MS=0,l1StartMs=0;
  const FEEDBACK_MS=600;

  // Target radius bands (applied to L1 and L2)
  const TARGET_R_MIN=140, TARGET_R_MAX=220;

  // L2 tuning — target size is adjustable
  let L2_SPIN_PERIOD_MS=1150;
  const L2_TOL_DEG=10,L2_HOLD_MS=1500,ROUND_MS=10000;
  let L2_TARGET_DIAM=56; // <-- now dynamic via slider
  let l2TargetAngle=0, l2TargetR=180;

  // L3 tuning
  let L3_SPIN_PERIOD_MS=1150,L3_GOAL_R=32,L3_LIVES_START=3;
  const L3_OBS_COUNT=5,L3_OBS_R_MIN=26,L3_OBS_R_MAX=48,L3_MARGIN=40,L3_MIN_GAP=140;
  let L3_MAX_SPEED=220,L3_ACCEL=520,L3_DAMPING_S=1.6;

  // State
  let airRoll=+1,center,level=1,JOY_CENTER,joyActive=false,joyVec=null,relocating=false;
  let smJoy={x:0,y:0},arrowAngleRender=0,lastFrameT,currentSpinAngle=0;
  let target=null,scoreHits=0,scoreTotal=0;
  let l2StartMs=0,l2HoldMs=0,l2ArrowActive=false;
  let l3Pos,l3Goal,l3Obstacles=[],l3Lives=L3_LIVES_START,l3Dist=0,l3ArrowActive=false,l3Vel=null;

  // L1 averaged capture state + hit dot
  let l1CapActive=false, l1CapStart=0, l1Cap = {x:0,y:0,w:0};
  let l1HitDot=null; // {x,y,until}

  // Hint state
  let joyHintUntil=0;

  // View (zoom)
  let viewScale = 1.0;
  const VIEW_MIN = 0.5, VIEW_MAX = 1.5, VIEW_STEP = 0.1;

  // Pinch state
  const touches = new Map(); // id -> {x,y}
  let pinchStartDist = 0, pinchStartScale = 1;

  // Setting: invert Up/Down mapping
  let invertUD=false;

  /* =================== Setup & UI =================== */
  function setup(){
    createCanvas(window.innerWidth,window.innerHeight);
    center=createVector(width/2,height/2);
    JOY_CENTER=createVector(110,Math.max(140,height-170));

    // Hamburger toggles chrome (sliders included)
    const menuBtn=document.getElementById('menuBtn'); let chromeShown=true;
    function setChromeShown(show){
      menuBtn.classList.toggle('active',!show);
      document.getElementById('ui').classList.toggle('hidden',!show);
      document.getElementById('hud').classList.toggle('hidden',!show);
      const l1spin=document.getElementById('l1SpinContainer');
      if(l1spin) l1spin.style.display=(level===1 && show)?'flex':'none';
      const l2size=document.getElementById('l2SizeContainer');
      if(l2size) l2size.style.display=(level===2 && show)?'flex':'none';
    }
    menuBtn.addEventListener('click',e=>{e.stopPropagation();chromeShown=!chromeShown;setChromeShown(chromeShown);});

    // Buttons
    bind('level1',()=>setLevel(1)); bind('level2',()=>setLevel(2)); bind('level3',()=>setLevel(3));
    bind('rollL',()=>setRoll(-1));  bind('rollR',()=>setRoll(+1));
    bind('restart',()=>restart());

    // Zoom buttons + slider
    bind('zoomIn',()=>{ setZoom(viewScale+VIEW_STEP); });
    bind('zoomOut',()=>{ setZoom(viewScale-VIEW_STEP); });
    const zoomRange=document.getElementById('zoomRange');
    if(zoomRange){
      zoomRange.addEventListener('input',()=> setZoom(parseFloat(zoomRange.value)||1));
    }

    const swapBtn=document.getElementById('swapUD');
    swapBtn.addEventListener('click',e=>{
      e.stopPropagation(); invertUD=!invertUD;
      swapBtn.classList.toggle('active',invertUD);
      swapBtn.textContent=invertUD?'Swap U/D: ON':'Swap U/D';
    });

    // L2/L3 spin slider
    const spinRange=document.getElementById('spinRange'),spinValue=document.getElementById('spinValue'),spinLabelPrefix=document.getElementById('spinLabelPrefix');
    if(spinRange){
      spinRange.value="1.15"; spinValue.textContent="1.15 s/rot"; spinLabelPrefix.textContent="L2 Spin";
      spinRange.addEventListener('input',()=>{
        const s=Math.max(1.15,Math.min(3.0,parseFloat(spinRange.value)));
        if(level===2)L2_SPIN_PERIOD_MS=s*1000; else if(level===3)L3_SPIN_PERIOD_MS=s*1000;
        spinValue.textContent=s.toFixed(2)+' s/rot'; updateTempoTag();
      });
    }

    // L1 Difficulty slider
    const diffRange=document.getElementById('diffRange'),diffTag=document.getElementById('diffTag');
    if(diffRange){
      const apply=()=>{
        const d=parseInt(diffRange.value,10);
        const tol=14-(d-1)*2,rad=28-(d-1)*2.5,win=[0,160,130,100,85,70][d];
        L1_TOL_DEG=tol; L1_TARGET_RADIUS=Math.round(rad); HOLD_TO_ARC_MS=win;
        diffTag.textContent=`Tol ${tol}° • Radius ${Math.round(rad)} • Window ${win}ms`;
        if(level===1 && target){
          const fit=fitTargetAtAngle(target.angle,target.r,L1_TARGET_RADIUS+8);
          target.r=fit.r; target.x=fit.x; target.y=fit.y;
        }
      };
      diffRange.addEventListener('input',apply); apply();
    }

    // L1 spin slider (vertical)
    (function initL1EdgeSlider(){
      const slider=document.getElementById('l1SpinSlider'),label=document.getElementById('l1SpinLabel');
      if(!slider||!label) return;
      function apply(val){
        if(val===0){label.textContent='Spin: 0 (stationary)';L1_SPIN_PERIOD_MS=0;}
        else{const s=3.0-(2.5*val);label.textContent=`Spin: ${s.toFixed(2)} s/rot`;L1_SPIN_PERIOD_MS=s*1000;l1StartMs=millis();}
      }
      slider.addEventListener('input',()=>apply(parseFloat(slider.value)||0));
      apply(parseFloat(slider.value)||0);
    })();

    // L2 target-size slider (vertical)
    (function initL2SizeSlider(){
      const slider=document.getElementById('l2SizeSlider'),label=document.getElementById('l2SizeLabel');
      if(!slider||!label) return;
      function apply(px){
        L2_TARGET_DIAM = Math.max(36, Math.min(120, px|0));
        label.textContent = `Target Ø: ${L2_TARGET_DIAM}px`;
        // Keep current target clamped to screen when size changes
        if(level===2){
          const fit=fitTargetAtAngle(l2TargetAngle,l2TargetR, (L2_TARGET_DIAM/2)+24);
          l2TargetR=fit.r;
        }
      }
      slider.addEventListener('input',()=>apply(parseFloat(slider.value)||56));
      apply(parseFloat(slider.value)||56);
    })();

    // Canvas joystick + pinch zoom
    attachCanvasJoystickHandlers();

    window.addEventListener('resize',windowResized);

    setRoll(+1); setLevel(1); restart(); showGoal();
    showJoyHint(JOY_HINT_MS);

    // draw loop (pause when hidden)
    lastFrameT=millis();
    function frame(){ if(document.hidden){ lastFrameT=millis(); requestAnimationFrame(frame); return; }
      const t=millis(); const dt=Math.max(1,t-lastFrameT); lastFrameT=t; draw(dt); requestAnimationFrame(frame);
    }
    requestAnimationFrame(frame);
  }

  function windowResized(){
    resizeCanvas(window.innerWidth,window.innerHeight);
    center=createVector(width/2,height/2);
    if(!relocating) JOY_CENTER=createVector(110,Math.max(140,height-170));
    if(level===1 && target){
      const fit=fitTargetAtAngle(target.angle,target.r, L1_TARGET_RADIUS+8);
      target.r=fit.r; target.x=fit.x; target.y=fit.y;
    }
    if(level===2){
      const fit=fitTargetAtAngle(l2TargetAngle,l2TargetR, (L2_TARGET_DIAM/2)+24);
      l2TargetR=fit.r;
    }
    if(level===3){clampCourseForScreen();}
    positionJoyHint();
  }

  function bind(id,fn){const el=document.getElementById(id); el.addEventListener('click',e=>{e.stopPropagation();fn();}); el.addEventListener('pointerdown',e=>{e.stopPropagation();fn();}); return el;}
  function setLevel(n){
    level=n;
    document.getElementById('level1').classList.toggle('active',n===1);
    document.getElementById('level2').classList.toggle('active',n===2);
    document.getElementById('level3').classList.toggle('active',n===3);
    document.getElementById('level2hud').style.display=(n===2)?'flex':'none';
    document.getElementById('level3hud').style.display=(n===3)?'flex':'none';
    document.getElementById('spinControls').style.display=(n===2||n===3)?'flex':'none';
    document.getElementById('l1Diff').style.display=(n===1)?'flex':'none';

    // show left-edge vertical slider for the active level
    const l1spin=document.getElementById('l1SpinContainer');
    const l2size=document.getElementById('l2SizeContainer');
    const chromeShown=!document.getElementById('menuBtn').classList.contains('active');
    if(l1spin) l1spin.style.display=(n===1 && chromeShown)?'flex':'none';
    if(l2size) l2size.style.display=(n===2 && chromeShown)?'flex':'none';

    const spinRange=document.getElementById('spinRange'),spinValue=document.getElementById('spinValue'),spinLabelPrefix=document.getElementById('spinLabelPrefix');
    if(spinRange&&spinValue){const val=(n===2?L2_SPIN_PERIOD_MS:L3_SPIN_PERIOD_MS)/1000; spinRange.value=val.toFixed(2); spinValue.textContent=val.toFixed(2)+' s/rot'; spinLabelPrefix.textContent=(n===2?'L2 Spin':'L3 Spin');}
    updateTempoTag(); restart(); showGoal();
    showJoyHint(JOY_HINT_MS * 0.75);
  }

  function setRoll(dir){airRoll=dir; document.getElementById('rollL').classList.toggle('active',dir<0); document.getElementById('rollR').classList.toggle('active',dir>0);}
  function updateTempoTag(){const tempo=document.getElementById('tempoTag'); if(!tempo) return; const s=(level===2?L2_SPIN_PERIOD_MS:L3_SPIN_PERIOD_MS)/1000; tempo.textContent=`Tempo ${s.toFixed(2)} s/rot`; }

  function goalTextFor(lv){
    if(lv===1) return {title:'Level 1 — Quick Aim',text:'A target spawns near the square. Flick toward it quickly. Your aim is averaged over a short window (earlier movement counts more), then judged against the target.'};
    if(lv===2) return {title:'Level 2 — Match the Spin',text:'The square spins. Use the joystick to aim your arrow at the yellow target. Hold on target long enough to lock it. The spin changes your aim — counter the rotation.'};
    return {title:'Level 3 — Navigate the Course',text:'Push the joystick to set a heading relative to the spinning square. Avoid obstacles and reach the green goal before you run out of lives.'};
  }

  /* ===== Hint / Goal panel toggle ===== */
  let goalHideTimer = null;
  let goalVisible = false;

  function showGoal(force = false){
    const panel = document.getElementById('goalPanel');
    const { title, text } = goalTextFor(level);
    document.getElementById('goalTitle').textContent = title;
    document.getElementById('goalText').textContent = text;

    panel.classList.remove('hidden');
    goalVisible = true;

    if (goalHideTimer) clearTimeout(goalHideTimer);
    if (!force) goalHideTimer = setTimeout(() => { hideGoal(); }, GOAL_MS);
  }

  function hideGoal(){
    const panel=document.getElementById('goalPanel');
    panel.classList.add('hidden');
    goalVisible = false;
    if (goalHideTimer){ clearTimeout(goalHideTimer); goalHideTimer=null; }
  }

  function toggleGoal(){ if(goalVisible) hideGoal(); else showGoal(true); }

  document.getElementById('goalClose').addEventListener('click',(e)=>{e.stopPropagation();hideGoal();});
  document.getElementById('goalPanel').addEventListener('click',(e)=>{ if(e.target.id==='goalPanel') hideGoal(); });
  document.getElementById('hintBtn').addEventListener('click',(e)=>{e.stopPropagation();toggleGoal();});

  /* ===== Joy reposition hint helpers ===== */
  function showJoyHint(ms){
    const el=document.getElementById('joyHint');
    joyHintUntil=millis()+ms;
    el.classList.add('show');
    positionJoyHint();
  }
  function maybeHideJoyHint(){
    const el=document.getElementById('joyHint');
    if(millis()>joyHintUntil) el.classList.remove('show');
  }
  function positionJoyHint(){
    const x=JOY_CENTER.x + (JOY_BASE_R+18);
    const y=JOY_CENTER.y - (JOY_BASE_R+18);
    const el=document.getElementById('joyHint');
    el.style.left=x+'px'; el.style.top=y+'px';
  }

  function updateScore(msg){
    const el=document.getElementById('score'); if(el) el.textContent=`Score ${scoreHits} / ${scoreTotal}`;
    const r=document.getElementById('result'); if(!r) return;
    if(!msg){r.style.display='none';return;}
    r.textContent=msg.text; r.style.display='inline-block'; r.className='tag '+(msg.good?'good':'bad');
    setTimeout(()=>{r.style.display='none';}, FEEDBACK_MS);
  }

  /* =================== Math helpers =================== */
  function emaAlpha(dt,tau){return 1-Math.exp(-dt/Math.max(1,tau));}
  function angleLerp(cur,tgt,a){let d=tgt-cur;while(d>Math.PI)d-=2*Math.PI;while(d<-Math.PI)d+=2*Math.PI;return cur+d*a;}
  function normPi(a){while(a>Math.PI)a-=2*Math.PI;while(a<-Math.PI)a+=2*Math.PI;return a;}
  function mirrorY(a){return Math.PI - a;} // maps screen coords to square-relative

  /* =================== Targets & restart =================== */
  function fitTargetAtAngle(angle,desiredR,margin){
    const cx=center.x,cy=center.y;const c=Math.cos(angle),s=Math.sin(angle);const cand=[];
    if(Math.abs(c)>1e-6){const rL=(margin-cx)/c,rR=(width-margin-cx)/c;if(rL>0)cand.push(rL);if(rR>0)cand.push(rR);}
    if(Math.abs(s)>1e-6){const rT=(margin-cy)/s,rB=(height-margin-cy)/s;if(rT>0)cand.push(rT);if(rB>0)cand.push(rB);}
    const valid=cand.filter(Number.isFinite);const maxR=valid.length?Math.min(...valid):desiredR;const rUsed=Math.max(0,Math.min(desiredR,maxR));
    return {r:rUsed,x:cx+rUsed*c,y:cy+rUsed*s};
  }

  // L1: spawn in a defined radius band around center, clamped to screen
  function spawnTarget(){
    const angle=random(-Math.PI,Math.PI);
    const preferred = random(TARGET_R_MIN, TARGET_R_MAX);
    const fit=fitTargetAtAngle(angle,preferred,L1_TARGET_RADIUS+8);
    target={angle,r:fit.r,x:fit.x,y:fit.y};
  }

  // L2: spawn in the same philosophy (band + clamp), size from slider
  function spawnL2Target(){
    l2TargetAngle = random(-Math.PI, Math.PI);
    const preferred = random(TARGET_R_MIN, TARGET_R_MAX);
    const fit = fitTargetAtAngle(l2TargetAngle, preferred, (L2_TARGET_DIAM/2) + 24);
    l2TargetR = fit.r;
  }

  function restart(){
    joyActive=false; joyVec=null; smJoy.x=0; smJoy.y=0; arrowAngleRender=0;
    l1CapActive=false; l1CapStart=0; l1Cap={x:0,y:0,w:0};
    l1HitDot=null; // clear on restart only
    const res=document.getElementById('result'); if(res) res.style.display='none';

    if(level===1){
      scoreHits=0; scoreTotal=0; updateScore(); spawnTarget(); l1StartMs=millis();
    } else if(level===2){
      l2StartMs=millis(); l2HoldMs=0; l2ArrowActive=false;
      spawnL2Target();
      document.getElementById('aimTag').textContent='Aim —';
    } else {
      l3Dist=0; l3Lives=L3_LIVES_START; l3ArrowActive=false;
      l3Pos=createVector(width*0.5, height*0.75); l3Vel=createVector(0,0);
      generateCourse(); updateL3Hud();
    }
  }

  /* =================== Level 3 course =================== */
  function randRange(a,b){return a+Math.random()*(b-a);}
  function farEnough(x,y,list,r){for(const it of list){const gap=dist(x,y,it.x,it.y)-(r+it.r);if(gap<L3_MIN_GAP)return false;}return true;}
  function generateCourse(){
    l3Goal={x:width*.5,y:L3_MARGIN+70,r:L3_GOAL_R}; l3Obstacles=[];
    let tries=0; while(l3Obstacles.length<L3_OBS_COUNT && tries<1000){
      tries++; const r=randRange(L3_OBS_R_MIN,L3_OBS_R_MAX);
      const x=randRange(L3_MARGIN+r,width-L3_MARGIN-r), y=randRange(L3_MARGIN+r+40,height-L3_MARGIN-r-120);
      if(dist(x,y,l3Pos.x,l3Pos.y)<(r+160)) continue;
      if(dist(x,y,l3Goal.x,l3Goal.y)<(r+160)) continue;
      if(!farEnough(x,y,l3Obstacles,r)) continue;
      l3Obstacles.push({x,y,r});
    }
    clampCourseForScreen();
  }
  function clampCourseForScreen(){
    for(const o of l3Obstacles){o.x=Math.max(L3_MARGIN+o.r,Math.min(width-L3_MARGIN-o.r,o.x));o.y=Math.max(L3_MARGIN+o.r,Math.min(height-L3_MARGIN-o.r,o.y));}
    l3Goal.x=Math.max(L3_MARGIN+l3Goal.r,Math.min(width-L3_MARGIN-l3Goal.r,l3Goal.x));
    l3Goal.y=Math.max(L3_MARGIN+l3Goal.r,Math.min(height-L3_MARGIN-l3Goal.r,l3Goal.y));
    if(l3Pos){l3Pos.x=Math.max(SQUARE_HALF+4,Math.min(width-(SQUARE_HALF+4),l3Pos.x));l3Pos.y=Math.max(SQUARE_HALF+4,Math.min(height-(SQUARE_HALF+4),l3Pos.y));}
  }
  function updateL3Hud(){
    const sp=document.getElementById('speedTag'); if(sp){const cur=(l3Vel?l3Vel.mag():0); sp.textContent=`Speed ${cur.toFixed(0)} px/s`; }
    const dt=document.getElementById('distTag'); if(dt) dt.textContent=`Dist ${(l3Dist/100).toFixed(1)} m`;
    const lv=document.getElementById('livesTag'); if(lv) lv.textContent=`Lives ${l3Lives}`;
  }

  /* =================== Joystick (touch) + Pinch Zoom =================== */
  function inJoyLoose(x,y){
    const dx=x-JOY_CENTER.x, dy=y-JOY_CENTER.y;
    const r2=dx*dx+dy*dy, loose=(JOY_BASE_R+28);
    const inCircle=r2<=loose*loose;
    const inBand=(Math.abs(dx)<=JOY_BASE_R)&&(Math.abs(dy)<=JOY_BASE_R+40);
    return inCircle||inBand;
  }
  function vecFromJoyPx(x,y){
    let dx=x-JOY_CENTER.x, dy=y-JOY_CENTER.y;
    const m=Math.hypot(dx,dy); if(m>JOY_BASE_R){const k=JOY_BASE_R/(m||1); dx*=k; dy*=k;}
    return createVector(dx,dy);
  }
  function setZoom(z){
    viewScale = Math.max(VIEW_MIN, Math.min(VIEW_MAX, z));
    const tag = document.getElementById('zoomTag');
    if(tag) tag.textContent = `Zoom ${viewScale.toFixed(2)}×`;
    const zr = document.getElementById('zoomRange');
    if(zr && Math.abs((parseFloat(zr.value)||1) - viewScale) > 1e-3){
      zr.value = viewScale.toFixed(2);
    }
  }
  function distance(p1,p2){const dx=p1.x-p2.x,dy=p1.y-p2.y;return Math.hypot(dx,dy);}

  function attachCanvasJoystickHandlers(){
    const RELOCATE_HOLD_MS = 250; // must hold outside for 0.25s to start reposition
    let activeId = null;
    let holdTimer = null;
    let pressedOutside = false;

    canvas.addEventListener('pointerdown', (e) => {
      try { e.target.setPointerCapture(e.pointerId); } catch(_) {}
      touches.set(e.pointerId, {x:e.clientX,y:e.clientY});

      if (touches.size >= 2){
        // Begin pinch
        const [a,b] = [...touches.values()];
        pinchStartDist = distance(a,b);
        pinchStartScale = viewScale;
        clearTimeout(holdTimer);
        pressedOutside = false;
        return;
      }

      activeId = e.pointerId;
      const inside = inJoyLoose(e.clientX, e.clientY);
      pressedOutside = !inside;

      if (inside) {
        // joystick only
        joyActive = true;
        joyVec = vecFromJoyPx(e.clientX, e.clientY);
        if (level === 1 && !l1CapActive) l1StartCapture();
      } else {
        // require a short hold before entering relocate mode
        clearTimeout(holdTimer);
        holdTimer = setTimeout(() => {
          if (pressedOutside && activeId === e.pointerId){
            relocating = true;
            JOY_CENTER = createVector(e.clientX, e.clientY);
            positionJoyHint();
          }
        }, RELOCATE_HOLD_MS);
      }
      e.preventDefault();
    }, { passive:false });

    canvas.addEventListener('pointermove', (e) => {
      const t = touches.get(e.pointerId);
      if(t){ t.x=e.clientX; t.y=e.clientY; }

      if (touches.size >= 2){
        // Pinch zoom
        const [a,b] = [...touches.values()];
        const cur = distance(a,b);
        if (pinchStartDist>0){
          const factor = cur / pinchStartDist;
          setZoom( pinchStartScale * factor );
        }
        return;
      }

      if (relocating){
        JOY_CENTER = createVector(e.clientX, e.clientY);
        positionJoyHint();
      } else if (joyActive && activeId === e.pointerId){
        joyVec = vecFromJoyPx(e.clientX, e.clientY);
      }
      e.preventDefault();
    }, { passive:false });

    function endPtr(e){
      try { canvas.releasePointerCapture(e.pointerId); } catch(_) {}
      touches.delete(e.pointerId);

      if (touches.size < 2){
        pinchStartDist = 0;
      }

      clearTimeout(holdTimer);
      pressedOutside = false;

      if (joyActive && activeId === e.pointerId){
        joyActive = false;
        joyVec = null;
        if (level === 1 && l1CapActive) l1FinalizeCapture();
      }
      if (activeId === e.pointerId){
        relocating = false;
        activeId = null;
      }
      e.preventDefault();
    }
    canvas.addEventListener('pointerup', endPtr, { passive:false });
    canvas.addEventListener('pointercancel', endPtr, { passive:false });
  }

  /* ===== Level 1 averaged capture ===== */
  function l1StartCapture(){
    l1CapActive=true; l1CapStart=millis(); l1Cap={x:0,y:0,w:0};
  }
  function l1FeedCapture(dx,dy){
    const age = millis()-l1CapStart;
    const tau = Math.max(20, HOLD_TO_ARC_MS*0.6);
    const w = Math.exp(-age / tau);
    l1Cap.x += dx*w; l1Cap.y += dy*w; l1Cap.w += w;
  }
  function l1FinalizeCapture(){
    if(!l1CapActive) return;
    l1CapActive=false;

    if(l1Cap.w<=0){ scoreTotal++; updateScore({text:'Miss',good:false}); spawnTarget(); updateScore(); return; }

    const avgx=l1Cap.x/l1Cap.w, avgy=l1Cap.y/l1Cap.w;
    const mag=Math.hypot(avgx,avgy);
    if(mag<STICK_MIN_MAG*0.9){ scoreTotal++; updateScore({text:'Miss (weak flick)',good:false}); spawnTarget(); updateScore(); return; }

    l1EvaluateFromAveragedVector(avgx,avgy);
  }
  function l1EvaluateFromAveragedVector(dx,dy){
    const raw=Math.atan2( (invertUD ? dy : -dy), dx);
    const spin=l1CurrentSpinAngle();
    const hitAngle=spin+mirrorY(raw);

    // Hit dot at the same distance as the on-screen arrow tip
    const hx = center.x + Math.cos(hitAngle) * ARROW_LEN;
    const hy = center.y + Math.sin(hitAngle) * ARROW_LEN;
    l1HitDot = {x: hx, y: hy, until: millis()+1600};

    let err=hitAngle - target.angle;
    while(err>Math.PI) err-=2*Math.PI;
    while(err<-Math.PI) err+=2*Math.PI;
    const errDeg=Math.abs(degrees(err));

    scoreTotal++;
    if(errDeg<=L1_TOL_DEG){ scoreHits++; updateScore({text:'Hit!',good:true}); }
    else{ updateScore({text:`Miss (${errDeg.toFixed(0)}°)`,good:false}); }

    updateScore();
    spawnTarget();
  }

  /* =================== Rendering =================== */
  function drawGrid(){stroke('#282a30');strokeWeight(1);for(let x=0;x<width;x+=40)line(x,0,x,height);for(let y=0;y<height;y+=40)line(0,y,width,y);}

  function drawSquareColored(pos,angle){
    push();translate(pos.x,pos.y);rotate(angle);noFill();strokeWeight(4);
    stroke(COL_UP);   line(-SQUARE_HALF,-SQUARE_HALF, SQUARE_HALF,-SQUARE_HALF);
    stroke(COL_LEFT); line( SQUARE_HALF,-SQUARE_HALF, SQUARE_HALF, SQUARE_HALF);
    stroke(COL_DOWN); line( SQUARE_HALF, SQUARE_HALF,-SQUARE_HALF, SQUARE_HALF);
    stroke(COL_RIGHT);line(-SQUARE_HALF, SQUARE_HALF,-SQUARE_HALF,-SQUARE_HALF);
    stroke('#53d769');strokeWeight(4); line(0,0,0,SQUARE_HALF+16);
    pop();
  }

  function drawArrowWorld(origin,angle,color){
    const ax=origin.x+Math.cos(angle)*ARROW_LEN, ay=origin.y+Math.sin(angle)*ARROW_LEN;
    stroke(color);strokeWeight(6);line(origin.x,origin.y,ax,ay);
    push();translate(ax,ay);rotate(angle);fill(color);noStroke();
    ctx.beginPath();ctx.moveTo(0,0);ctx.lineTo(-14,-8);ctx.lineTo(-14,8);ctx.closePath();ctx.fill();pop();
  }

  function drawJoystick(){
    const cx=JOY_CENTER.x,cy=JOY_CENTER.y,r=JOY_BASE_R;
    // pulsating halo
    const t=millis(); const pulse = 1 + 0.06*Math.sin(t*0.008);
    const haloR = r * pulse + 6;
    noFill(); strokeWeight(6); stroke(`rgba(76,141,255,0.20)`); circle(cx,cy,haloR*2);

    // ring quadrants
    noFill();strokeWeight(10);
    stroke(COL_RIGHT);arc(cx,cy,r*2,r*2,radians(-45),radians(45));
    stroke(COL_UP);   arc(cx,cy,r*2,r*2,radians(45),radians(135));
    stroke(COL_LEFT); arc(cx,cy,r*2,r*2,radians(135),radians(225));
    stroke(COL_DOWN); arc(cx,cy,r*2,r*2,radians(225),radians(315));

    // inner guides + knob
    noFill();stroke('#2d2d2d');strokeWeight(2);circle(cx,cy,(r-22)*2);
    stroke('#373737');line(cx-r+10,cy,cx+r-10,cy);line(cx,cy-r+10,cx,cy+r-10);
    const knob=joyVec?Vector.add(JOY_CENTER,joyVec):JOY_CENTER.copy();
    fill('#1e2127');stroke('#4c8dff');strokeWeight(3);circle(knob.x,knob.y,JOY_KNOB_R*2);
  }

  /* =================== Spin helpers =================== */
  function l1CurrentSpinAngle(){
    if(L1_SPIN_PERIOD_MS<=0) return Math.PI;
    const dir=(airRoll>0)?+1:-1;
    return Math.PI + dir * ((millis()-l1StartMs) * (2*Math.PI/L1_SPIN_PERIOD_MS));
  }

  /* =================== Game Loop =================== */
  function draw(dt){
    const a=emaAlpha(dt,STICK_TAU_MS);
    const tx=(joyVec?joyVec.x:0), ty=(joyVec?joyVec.y:0);
    smJoy.x+=(tx-smJoy.x)*a; smJoy.y+=(ty-smJoy.y)*a;

    background('#0e0f12');

    // ---- Begin scene zoom transform (game world only) ----
    push();
    translate(center.x, center.y);
    ctx.scale(viewScale, viewScale);
    translate(-center.x, -center.y);

    drawGrid();
    if(level===1) runLevel1(dt); else if(level===2) runLevel2(dt); else runLevel3(dt);

    pop();
    // ---- End scene zoom transform ----

    // UI elements drawn at 1:1
    drawJoystick();
    maybeHideJoyHint();

    // Feed L1 capture while active; auto-finalize on timeout
    if(level===1 && l1CapActive){
      if(joyVec){ l1FeedCapture(smJoy.x, smJoy.y); }
      if(millis()-l1CapStart >= Math.max(60, HOLD_TO_ARC_MS || 100)){
        l1FinalizeCapture();
      }
    }
  }

  function runLevel1(dt){
    const spin=l1CurrentSpinAngle();
    drawSquareColored(center,spin);

    // target & helper line
    if(target){
      noStroke();fill('#ffd166');circle(target.x,target.y,L1_TARGET_RADIUS*2);
      stroke('#5a5a5a');strokeWeight(2);line(center.x,center.y,target.x,target.y);
    }

    // show last hit dot if active (with outline so it pops)
    if(l1HitDot && millis() < l1HitDot.until){
      stroke('#ffffff'); strokeWeight(3);
      fill('#53d769'); circle(l1HitDot.x, l1HitDot.y, 14);
    }

    // arrow only while touching (visualization)
    if(joyActive&&joyVec){
      const raw=Math.atan2( (invertUD ? smJoy.y : -smJoy.y), smJoy.x);
      const thWorld=spin+mirrorY(raw);
      const col=arrowColorFor(thWorld,spin);
      drawArrowWorld(center,thWorld,col);
    }
  }

  function runLevel2(dt){
    const t=millis(), dir=(airRoll>0)?+1:-1, omega=dir*(Math.PI*2)/L2_SPIN_PERIOD_MS;
    const spin=omega*(t-l2StartMs); currentSpinAngle=spin;
    const mag=Math.hypot(smJoy.x,smJoy.y), active=mag>STICK_MIN_MAG;
    drawSquareColored(center,spin);

    // target (size = L2_TARGET_DIAM via slider)
    const tx=center.x+Math.cos(l2TargetAngle)*l2TargetR, ty=center.y+Math.sin(l2TargetAngle)*l2TargetR;
    noStroke();fill('#ffd166');circle(tx,ty,L2_TARGET_DIAM);

    if(active){
      const thStick=Math.atan2( (invertUD ? smJoy.y : -smJoy.y), smJoy.x);
      const thTarget=spin+mirrorY(thStick);
      if(!l2ArrowActive){arrowAngleRender=thTarget;l2ArrowActive=true;}
      const a=emaAlpha(dt,ARROW_TAU_MS); arrowAngleRender=angleLerp(arrowAngleRender,thTarget,a);
      const thRender=arrowAngleRender, col=arrowColorFor(thRender,spin);
      drawArrowWorld(center,thRender,col);

      let err=thRender-l2TargetAngle; while(err>Math.PI)err-=2*Math.PI; while(err<-Math.PI)err+=2*Math.PI;
      const errDeg=Math.abs(degrees(err)); document.getElementById('aimTag').textContent=`Aim ${errDeg.toFixed(0)}°`;
      if(errDeg<=L2_TOL_DEG) l2HoldMs+=dt; else l2HoldMs=0;
    } else {
      l2HoldMs=0; l2ArrowActive=false; document.getElementById('aimTag').textContent='Aim —';
    }

    updateTempoTag();
    if(l2HoldMs>=L2_HOLD_MS || (t-l2StartMs>ROUND_MS)){
      l2StartMs=millis(); l2HoldMs=0;
      spawnL2Target();
    }
  }

  function runLevel3(dt){
    updateL3Hud();
    if(!l3Pos){ l3Pos=createVector(width*0.5, height*0.75); l3Vel=createVector(0,0); }

    const t=millis(), dir=(airRoll>0)?+1:-1, omega=(Math.PI*2)/L3_SPIN_PERIOD_MS*dir;
    const spin=omega*(t-(l2StartMs||t)); currentSpinAngle=spin;

    let head=null; const mag=Math.hypot(smJoy.x,smJoy.y);
    if(mag>STICK_MIN_MAG){
      const thStick=Math.atan2( (invertUD ? smJoy.y : -smJoy.y), smJoy.x);
      head=spin+mirrorY(thStick);
      if(!l3ArrowActive){arrowAngleRender=head;l3ArrowActive=true;}
      const a=emaAlpha(dt,ARROW_TAU_MS); arrowAngleRender=angleLerp(arrowAngleRender,head,a);
    } else { l3ArrowActive=false; }

    // physics
    const dtSec=dt/1000;
    if(head!=null){
      const ax=Math.cos(head)*L3_ACCEL, ay=Math.sin(head)*L3_ACCEL;
      l3Vel.x+=ax*dtSec; l3Vel.y+=ay*dtSec;
      const sp=l3Vel.mag(); if(sp>L3_MAX_SPEED) l3Vel.mult(L3_MAX_SPEED/sp);
    } else {
      const damp=Math.exp(-dtSec/L3_DAMPING_S); l3Vel.mult(damp); if(l3Vel.mag()<3){l3Vel.x=0;l3Vel.y=0;}
    }
    l3Pos.x+=l3Vel.x*dtSec; l3Pos.y+=l3Vel.y*dtSec; l3Dist+=l3Vel.mag()*dtSec; clampCourseForScreen();

    // draw
    noStroke();fill('#7bd88f');circle(l3Goal.x,l3Goal.y,l3Goal.r*2);
    noFill();stroke('#ff9472');strokeWeight(3);for(const o of l3Obstacles){circle(o.x,o.y,o.r*2);}
    drawSquareColored(l3Pos,spin);
    if(head!=null){ const th=arrowAngleRender, col=arrowColorFor(th,spin); drawArrowWorld(l3Pos,th,col); }

    // collisions
    for(const o of l3Obstacles){ if(dist(l3Pos.x,l3Pos.y,o.x,o.y) < (SQUARE_HALF+4+o.r)){handleL3Crash();return;} }
    if(dist(l3Pos.x,l3Pos.y,l3Goal.x,l3Goal.y) < (SQUARE_HALF+4+l3Goal.r)){handleL3Win();return;}
  }

  function handleL3Crash(){
    l3Lives--; updateL3Hud();
    const r=document.getElementById('result'); if(r){r.textContent='Crash!'; r.className='tag bad'; r.style.display='inline-block';}
    if(l3Lives<=0){setTimeout(()=>{restart();},650);}
    else{setTimeout(()=>{l3Pos=createVector(width*.5,height*.75); l3Vel=createVector(0,0); const r=document.getElementById('result'); if(r) r.style.display='none';},650);}
  }
  function handleL3Win(){
    const r=document.getElementById('result'); if(r){r.textContent='Goal!'; r.className='tag good'; r.style.display='inline-block';}
    setTimeout(()=>{restart();},800);
  }

  function arrowColorFor(thWorld,spin){
    const rel=normPi(thWorld-spin);
    if(rel>-Math.PI/4 && rel<= Math.PI/4) return COL_LEFT;   // right (yellow)
    if(rel> Math.PI/4 && rel<= 3*Math.PI/4) return COL_DOWN;  // bottom (green)
    if(rel<=-Math.PI/4 && rel> -3*Math.PI/4) return COL_UP;   // top (red)
    return COL_RIGHT;                                         // left (blue)
  }

  /* =================== Boot =================== */
  setup();
  </script>
</body>
</html>
